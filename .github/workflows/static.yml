# Simple workflow for deploying static content to GitHub Pages
name: Deploy static content to Pages

on:
  # Runs on pushes targeting the default branch
  push:
    branches: ["main"]

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

# Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages
permissions:
  contents: read
  pages: write
  id-token: write

# Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued.
# However, do NOT cancel in-progress runs as we want to allow these production deployments to complete.
concurrency:
  group: "pages"
  cancel-in-progress: false

jobs:
  # Single deploy job since we're just deploying
  deploy:
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Setup Pages
        uses: actions/configure-pages@v5
      
      - name: Prepare content for deployment
        run: |
          # Make sure we have a valid out directory with content
          if [ ! -d "./out" ] || [ ! -f "./out/index.html" ]; then
            echo "Error: No valid out directory with index.html found!"
            exit 1
          fi
          
          # Create necessary files directly in the out directory
          touch ./out/.nojekyll
          echo "backus.agency" > ./out/CNAME
          
          # Add CSS variables directly to avoid JavaScript dependency
          cat > ./out/variables.css << EOF
          :root {
            --primary: #3498db !important;
            --secondary: #2ecc71 !important;
            --secondary-light: #4cd787 !important;
            --primary-foreground: #ffffff !important;
            --primary-light: #5faee3 !important;
          }
          EOF
          
          # Add CSS and metadata to all HTML files with high browser compatibility
          find ./out -name "*.html" | while read file; do
            # First add the required meta tags
            sed -i 's#<meta name="viewport"#<meta name="github-repo-owner" content="TheBackusAgency">\n<meta name="github-repo-name" content="tba-static">\n<meta name="viewport"#' "$file"
            
            # Then add CSS variables as early as possible for immediate styling
            sed -i 's#<head>#<head>\n<link rel="stylesheet" href="/variables.css">#' "$file"
            
            # Add a browser compatibility meta tag
            sed -i 's#<head>#<head>\n<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">#' "$file"
          done
          
          # More robust form handler with cross-browser compatibility
          cat > ./out/form-handler.js << EOF
          (function() {
            // Function to safely get repository metadata
            function getRepoInfo() {
              var owner = 'TheBackusAgency';
              var repo = 'tba-static';
              
              try {
                var ownerMeta = document.querySelector('meta[name="github-repo-owner"]');
                var repoMeta = document.querySelector('meta[name="github-repo-name"]');
                
                if (ownerMeta && ownerMeta.content) {
                  owner = ownerMeta.content;
                }
                
                if (repoMeta && repoMeta.content) {
                  repo = repoMeta.content;
                }
              } catch (e) {
                console.error('Error getting repo info:', e);
              }
              
              return { owner: owner, repo: repo };
            }
            
            // Handle form submission in a cross-browser compatible way
            function handleFormSubmit(e) {
              e.preventDefault();
              
              var form = e.target;
              var formType = form.getAttribute('data-form-type') || 'contact';
              
              // Get form data - using older syntax for IE compatibility
              var formData = {};
              var formElements = form.elements;
              
              for (var i = 0; i < formElements.length; i++) {
                var element = formElements[i];
                if (element.name && element.value) {
                  formData[element.name] = element.value;
                }
              }
              
              // Get repository info
              var repoInfo = getRepoInfo();
              
              // Format issue data
              var issueBody = '';
              for (var key in formData) {
                if (formData.hasOwnProperty(key)) {
                  issueBody += key + ': "' + formData[key] + '"\\n';
                }
              }
              
              // Build GitHub issue URL
              var url = 'https://github.com/' + repoInfo.owner + '/' + repoInfo.repo + 
                        '/issues/new?title=Form+Submission:+' + encodeURIComponent(formType) + 
                        '+Form&body=' + encodeURIComponent(issueBody) + 
                        '&labels=form-submission,' + encodeURIComponent(formType);
              
              // Use a fallback approach for opening windows
              try {
                var newWindow = window.open(url, '_blank');
                if (!newWindow || newWindow.closed || typeof newWindow.closed === 'undefined') {
                  // Popup blocked, fallback to location change
                  window.location.href = url;
                }
              } catch (e) {
                window.location.href = url;
              }
              
              // Show success message
              alert('Form submitted successfully! Redirecting to GitHub to complete submission.');
              
              // Reset form
              form.reset();
              
              // Show success message if there's a message container
              var messageContainer = form.querySelector('.form-message');
              if (messageContainer) {
                messageContainer.style.display = 'block';
                messageContainer.innerHTML = '<div class="p-3 bg-green-500/20 border border-green-500/50 rounded-md text-white mt-4">Form submitted successfully!</div>';
                
                // Hide message after 5 seconds
                setTimeout(function() {
                  messageContainer.style.display = 'none';
                }, 5000);
              }
            }
            
            // Initialize form handling when DOM is ready
            function initForms() {
              var forms = document.querySelectorAll('form');
              
              for (var i = 0; i < forms.length; i++) {
                var form = forms[i];
                
                // Prevent multiple handlers from being attached
                if (!form.getAttribute('data-handler-attached')) {
                  form.setAttribute('data-handler-attached', 'true');
                  form.addEventListener('submit', handleFormSubmit);
                }
              }
            }
            
            // Attach the handler depending on browser support
            if (document.readyState === 'loading') {
              document.addEventListener('DOMContentLoaded', initForms);
            } else {
              initForms();
            }
            
            // Also run on window load as a fallback
            window.addEventListener('load', initForms);
          })();
          EOF
          
          # Add the form handler to ALL HTML files to ensure it's available
          # This guarantees the script is loaded regardless of when/how forms appear
          find ./out -name "*.html" | while read file; do
            # First check if the script is already included
            if ! grep -q "form-handler.js" "$file"; then
              # Add the script just before closing body tag with proper attributes
              sed -i 's#</body>#<script src="/form-handler.js" type="text/javascript"></script></body>#' "$file"
            fi
          done
          
          # Also create a global CSS file for fixing cross-browser issues
          cat > ./out/browser-fixes.css << EOF
          /* Fix for Microsoft Edge and IE */
          .rounded-full {
            border-radius: 9999px !important;
          }
          
          /* Fix for form elements */
          input, select, textarea {
            color: white !important;
          }
          
          /* Fix for buttons in Firefox */
          button {
            cursor: pointer !important;
          }
          
          /* Fix for background gradients */
          .bg-gradient-to-br {
            background-image: linear-gradient(to bottom right, var(--secondary-light, #4cd787), var(--secondary, #2ecc71)) !important;
          }
          EOF
          
          # Add browser-fixes.css to all HTML files
          find ./out -name "*.html" | while read file; do
            # Add the browser fixes CSS file
            sed -i 's#</head>#<link rel="stylesheet" href="/browser-fixes.css">\n</head>#' "$file"
          done
          
          # Create 404 page if it doesn't exist
          if [ ! -f "./out/404.html" ]; then
            cp ./out/index.html ./out/404.html
          fi
      
      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3
        with:
          # Upload directly from the out directory instead of using root directory
          path: './out'
      
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4